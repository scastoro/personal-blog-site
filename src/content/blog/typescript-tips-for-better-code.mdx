---
title: "5 TypeScript Tips for Writing Better Code"
description: "Practical TypeScript techniques that will make your code more maintainable, type-safe, and easier to work with."
pubDate: 2024-01-08T00:00:00.000Z
tags: ["typescript", "javascript", "best-practices", "web-development"]
draft: false
---

# 5 TypeScript Tips for Writing Better Code

TypeScript has transformed how I write JavaScript. Here are five practical tips I've learned that have significantly improved my code quality and development experience.

## 1. Use Union Types for Better API Design

Instead of accepting `any` or overly broad types, use union types to be explicit about what your functions accept:

```typescript
type Theme = 'light' | 'dark' | 'auto';
type ButtonVariant = 'primary' | 'secondary' | 'outline';

function setTheme(theme: Theme) {
  // TypeScript ensures only valid themes are passed
}
```

## 2. Leverage Template Literal Types

Template literal types are incredibly powerful for creating type-safe string patterns:

```typescript
type EventName = `on${Capitalize<string>}`;
type APIEndpoint = `/api/v1/${string}`;

// This ensures proper event naming
const handleClick: EventName = 'onClick'; // ✓
const handleHover: EventName = 'onhover'; // ✗ TypeScript error
```

## 3. Use `satisfies` for Better Type Inference

The `satisfies` operator helps maintain type safety while preserving literal types:

```typescript
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3
} satisfies Record<string, string | number>;

// TypeScript knows config.timeout is a number, not just string | number
```

## 4. Create Branded Types for Domain-Specific Values

Branded types prevent mixing up similar primitive types:

```typescript
type UserId = string & { __brand: 'UserId' };
type PostId = string & { __brand: 'PostId' };

function getUser(id: UserId) { /* ... */ }
function getPost(id: PostId) { /* ... */ }

// This prevents accidentally mixing up IDs
const userId = 'user_123' as UserId;
const postId = 'post_456' as PostId;

getUser(postId); // TypeScript error!
```

## 5. Use Utility Types for Transformations

TypeScript's built-in utility types can save you from writing complex type definitions:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  isActive: boolean;
}

// Create variations without repeating yourself
type PartialUser = Partial<User>; // All properties optional
type UserUpdate = Pick<User, 'name' | 'email'>; // Only specific props
type UserSummary = Omit<User, 'isActive'>; // Exclude specific props
```

## Bonus: Generic Constraints

Use generic constraints to create flexible yet type-safe functions:

```typescript
function getValue<T extends Record<string, any>, K extends keyof T>(
  obj: T,
  key: K
): T[K] {
  return obj[key];
}

const user = { name: 'John', age: 30 };
const name = getValue(user, 'name'); // TypeScript knows this is string
```

## Wrapping Up

These techniques have made my TypeScript code more robust and easier to maintain. The key is to let TypeScript's type system work for you, not against you. Start with strict type checking enabled and gradually adopt these patterns as they become natural.

Remember: good TypeScript isn't about having the most complex types – it's about expressing your intent clearly and catching errors before they reach production.